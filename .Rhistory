phy$tip.label
phy[[1]]
ree <- phy[[1]]
ree
match(tips, ree$tip.label)
tt <- match(tips, ree$tip.label)
tt
getMRCA(phy, tt)
find.mrca(tips, phy[[1]])
find.mrca(tips, phy[1])
phy[1]
phy[[1]]
find.mrca(tips, phy[[1]])
node <- find.mrca(tips, phy[[1]])
node
extract.clade(phy, node)
extract.clade(phy[[1]], node)
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:length(trees))#
	{#
		cat(i, "\n")#
		phy <- trees[i]#
		node <- find.mrca(tips, phy[[1]])#
#		cat(node, "\n")#
		pruned.trees[i] <- extract.clade(phy[[1]], node)#
	}#
	return(pruned.trees)#
}
blarg <- grlurb(tips, mammal.trees)
warnings
warnings()
mammal.trees[1]
mammal.trees[[1]]
length(mammal.trees[[1]])
length(mammal.trees[[]])
length(mammal.trees)
mam.trees <- list()#
for (i in 1:2)#
{#
	mam.trees[i] <- mammal.trees[i]$phy#
}
mam.trees
mam.trees[[1]]
mammal.trees
mammal.trees[i]
mam.trees <- list()#
for (i in 1:2)#
{#
	mam.trees[i] <- mammal.trees[i]#
}
mam.trees
mammal.trees[i]
mammal.trees[1]
plot(mammal.trees[1])
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:length(trees))#
	{#
		cat(i, "\n")#
		phy <- trees{[i]}#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[i] <- extract.clade(phy[[1]], node)#
	}#
	return(pruned.trees)#
}
tips <- c("Vulpes_velox", "Felis_manul")#
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:length(trees))#
	{#
		cat(i, "\n")#
		phy <- trees[i]#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[i] <- extract.clade(phy[[1]], node)#
	}#
	return(pruned.trees)#
}
blarg <- grlurb(tips, mammal.trees)
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:length(trees))#
	{#
		cat(i, "\n")#
		phy <- trees[[i]]#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[i] <- extract.clade(phy[[1]], node)#
	}#
	return(pruned.trees)#
}#
#
blarg <- grlurb(tips, mammal.trees)
trees <- mammal.trees
trees
		phy <- trees[[i]]
phy\
phy
		node <- find.mrca(tips, phy)
node
extract.clade(phy[[1]], node)
extract.clade(phy, node)
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:length(trees))#
	{#
		cat(i, "\n")#
		phy <- trees[[i]]#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[i] <- extract.clade(phy, node)#
	}#
	return(pruned.trees)#
}#
#
blarg <- grlurb(tips, mammal.trees)
warnings()
tips <- c("Vulpes_velox", "Felis_manul")#
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:length(trees))#
	{#
		cat(i, "\n")#
		phy <- trees[[i]]#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[[i]] <- extract.clade(phy, node)#
	}#
	return(pruned.trees)#
}#
#
blarg <- grlurb(tips, mammal.trees)
blarg
rm(blarg)
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:5)#
	{#
		cat(i, "\n")#
		phy <- trees[[i]]#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[[i]] <- extract.clade(phy, node)#
	}#
	return(pruned.trees)#
}
blarg <- grlurb(tips, mammal.trees)
blarg
blarg[1]
blarg[[1]]
plot(blarg[[1]])
blarg
fool <- unlist(blarg)
fool
rm(fool;)
rm(fool)
blarg
fool <- blarg[]
fool
fool <- blarg[[]]
tips <- c("Vulpes_velox", "Felis_manul")#
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:length(trees))#
	{#
		cat(i, "\n")#
		phy <- trees[[i]]#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[i] <- extract.clade(phy, node)#
	}#
	return(pruned.trees)#
}
tips <- c("Vulpes_velox", "Felis_manul")#
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:5)#
	{#
		cat(i, "\n")#
		phy <- trees[[i]]#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[i] <- extract.clade(phy, node)#
	}#
	return(pruned.trees)#
}
blarg <- grlurb(tips, mammal.trees)
grlurb <- function (tips, trees)#
{#
	pruned.trees <- c()#
	cat("length of 'trees' is:", length(trees), "\n")#
	for (i in 1:length(trees))#
	{#
		cat(i, "\n")#
		phy <- trees[[i]]#
		node <- find.mrca(tips, phy)#
#		cat(node, "\n")#
		pruned.trees[[i]] <- extract.clade(phy, node)#
	}#
	return(pruned.trees)#
}#
#
blarg <- grlurb(tips, mammal.trees)
blarg
carnivore.trees <- blarg
rm(blarg)
save(carnivore.trees, file="carnivore.trees.Rdata")
rm(list=ls())
load("/Users/josephwb/Projects/R_working/Fossil_MEDUSA/GSA_2011/Code/carnivore.trees.Rdata")
ls()
carnivore.trees
length(carnivore.trees)
carnivore.trees[1]
carnivore.trees[[1]]
carnivore.trees[[1]]$tip.label
for (i in 1:length(carnivore.trees))#
{#
	cat("# tips = ", length(carnivore.trees[[1]]$tip.label))#
}
for (i in 1:length(carnivore.trees))#
{#
	cat("# tips = ", length(carnivore.trees[[1]]$tip.label), "\n")#
}
carnivore.trees
ls()
setwd("/Users/josephwb/Idaho/NCEAS_Workshop/MEDUSA_Code")
load("/Users/josephwb/Idaho/NCEAS_Workshop/MEDUSA_Code/carnivora.RData")
ls()
carnivora
plot(carnivora$tree)
require(TurboMEDUSA)
require(turboMEDUSA)
xt.richness
foo <- runTurboMEDUSA(carnivora$tree, carnivora$ext.richness)
require(fossilMEDUSA)#
carny.res <- runFossilMEDUSA(phy=carnivora.tree, richness=carnivore.extant.richness)#
summarizeFossilMEDUSA(results=carny.res)
require(fossilMEDUSA)#
carny.res <- runFossilMEDUSA(phy=carnivora$tree, richness=carnivore$ext.richness)#
summarizeFossilMEDUSA(results=carny.res)
require(fossilMEDUSA)#
carny.res <- runFossilMEDUSA(phy=carnivora$tree, richness=carnivora$ext.richness)#
summarizeFossilMEDUSA(results=carny.res)
ls()
carnivora$ext.richness
fossil.richness.max <- read.csv("/Users/josephwb/Idaho/NCEAS_Workshop/MEDUSA_Code/Carnivore_richness_max-fossils.csv")
fossil.richness.max
fossil.res <- runFossilMEDUSA(phy=carnivora$tree, richness=fossil.richness.max)
summarizeFossilMEDUSA(results= fossil.res)
runFossilMEDUSA()
fossil.richness.all <- read.csv("/Users/josephwb/Idaho/NCEAS_Workshop/MEDUSA_Code/Carnivore_fossil_richness_multiple-timeslices.csv")
fossil.richness.all
fossil.max <- runFossilMEDUSA(phy=carnivora$tree, richness= fossil.richness.all)
runFossilMEDUSA()
runFossilMEDUSA
fossil.max <- runFossilMEDUSA(phy=carnivora$tree, richness= fossil.richness.all, initial.r=0.01)
fossil.max <- runFossilMEDUSA(phy=carnivora$tree, richness= fossil.richness.all, initial.r=0.001)
fossil.max <- runFossilMEDUSA(phy=carnivora$tree, richness= fossil.richness.all, initial.r=0.0001)
	res <- L
	res <- 0L
res
foo <- function (n)#
{#
	res <- 0L#
	for (i in 2:(n-1))#
	{#
		res++#
	}#
}
foo <- function (n)#
{#
	res <- 0L#
	for (i in 2:(n-1))#
	{#
		res <- res+1#
	}#
}
foo
foo(4)
foo <- function (n)#
{#
	res <- 0L#
	for (i in 2:(n-1))#
	{#
		res <- res+1#
	}#
	return(res)#
}
foo(4)
foo <- function (n)#
{#
	res <- 0L#
	for (i in 2:(n-1))#
	{#
		res <- res+i#
	}#
	return(res)#
}
foo(4)
foo(5)
foo(6)
foo(20)
numSubParameters <- function (n)#
{#
	res <- 0L#
	for (i in 2:(n-1))#
	{#
		res <- res+i#
	}#
	return(res)#
}
numSubParameters(20)
#This code fits various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper) to a given phylogeny, by maximum likelihood, using the Nelder-Mead algorithm#
#Outputs are the log-likelihood, the second order Akaike's Information Criterion, and the maximum likelihood estimates of the parameters of diversification. Depending on the model, these parameters include a combination of the speciation rate at present (lamb0), the exponential variation in speciation rate (alpha), the extinction rate at present (mu0), the exponential variation in extinction rate (beta) and the extinction fraction (extinction rate/speciation rate, eps). See notations in the PloSB 2010 paper.#
#The code uses the ape package#
#The code uses the getLikelihood.coalBD code. use source("getLikelihood.coalBD.r") #
#
fitcoalBD<-function (phylo,lamb0=0.1,alpha=1,mu0=0.01,beta=0,meth = "Nelder-Mead",N0=0,cst.lamb=FALSE,cst.mu=FALSE,fix.eps=FALSE,mu.0=FALSE,pos=TRUE,Vtimes=FALSE)#
#
#The default settings allow to fit the most general model where the rates of speciation and extinction vary over time without a fixed extinction fraction (Model 4d from the PloSB 2010 paper). cst.lamb=TRUE forces the speciation rate to be constant over time (used to fit Models 3, 5 and 4b). cst.mu=TRUE forces the extinction rate to be constant over time (used to fit Models 3, and 4a). fix.eps forces the extinction fraction to be constant over time (used to fit Model 4c). mu.0=TRUE forces the extinction rate to 0 (used to fit Models 5 and 6).#
#pos=TRUE (the default) forces the rates of speciation and extinction to be positive. pos=FALSE removes this forcing.#
#
{#
#lamb0=0.1;alpha=1;mu0=0.01;beta=0;N0=0;cst.lamb=TRUE;cst.mu=FALSE;fix.eps=FALSE;mu.0=FALSE;pos=TRUE;Vtimes=FALSE;meth = "Nelder-Mead";#
	#
	if (Vtimes==TRUE) {#
		Vtimes <- as.numeric(sort(phylo))#
		Ntips<-length(phylo)+1#
		if (N0==0) {N0<-Ntips}#
		} else {#
		Vtimes <- as.numeric(sort(branching.times(phylo)))#
		Ntips<-Ntip(phylo)#
		if (N0==0) {N0<-Ntips}#
		}#
			 #
	nbobs <- length(Vtimes)-1#
		#
	#pure birth	constant rates (Model 5)	#
	if (mu.0==TRUE & cst.lamb==TRUE)#
	{init<-c(lamb0)}#
	#
	#birth-death constant rates	(Model 3)#
	else if (cst.mu==TRUE & cst.lamb==TRUE) #
    {init <- c(lamb0,mu0)}#
	#
	#pure birth varying speciation rate (Model 6)#
	else if (mu.0==TRUE & cst.lamb==FALSE)#
	{init<-c(lamb0,alpha)}#
		#
	#birth-death varying speciation rate (Model 4a)#
	else if (cst.mu==TRUE & cst.lamb==FALSE) #
    {init <- c(lamb0,alpha,mu0)}#
    	#
    #birth-death varying extinction rate (Model 4b)#
    else if (cst.mu==FALSE & cst.lamb==TRUE) # troubleshoot#
   	{init <- c(lamb0,mu0,beta)}#
    #
    #birth-death varying speciation rate and constant extinction fraction (Model 4c)#
    else if (fix.eps==TRUE)#
    {init <- c(lamb0,alpha,mu0/lamb0)}#
    #
    #birth-death varying speciation and extinction rates (Model 4d)	#
    else#
    {init = c(lamb0,alpha,mu0,beta)}#
#
	nbpar<-length(init)#
	    	#
############################################################	#
    #
    if (mu.0==TRUE & cst.lamb==TRUE)#
    {optimLH.coalBD <- function(init) {#
        lamb0 <- init[1]#
        LH <- getLikelihood.coalBD(Vtimes,Ntips,lamb0,alpha=0,mu0=0,beta=0,N0,pos=pos)$res#
        return(-LH)}#
        } else if (cst.mu==TRUE & cst.lamb==TRUE) #
    {optimLH.coalBD <- function(init) {#
        lamb0 <- init[1]#
        mu0 <- init[2]#
        LH <- getLikelihood.coalBD(Vtimes,Ntips,lamb0,alpha=0,mu0,beta=0,N0,pos=pos)$res#
        return(-LH)}#
        } else if (mu.0==TRUE & cst.lamb==FALSE)#
    {optimLH.coalBD <- function(init) {#
        lamb0 <- init[1]#
        alpha <- init[2]#
        LH <- getLikelihood.coalBD(Vtimes,Ntips,lamb0,alpha,mu0=0,beta=0,N0,pos=pos)$res#
        return(-LH)}#
        } else if (cst.mu==TRUE & cst.lamb==FALSE) #
    {optimLH.coalBD <- function(init) {#
        lamb0 <- init[1]#
        alpha <- init[2]#
        mu0 <- init[3]#
        LH <- getLikelihood.coalBD(Vtimes,Ntips,lamb0,alpha,mu0,beta=0,N0,pos=pos)$res#
        return(-LH)}#
        } else if (cst.mu==FALSE & cst.lamb==TRUE)#
	{optimLH.coalBD <- function(init) {#
        lamb0 <- init[1]#
        mu0 <- init[2]#
        beta<- init[3]#
        LH <- getLikelihood.coalBD(Vtimes,Ntips,lamb0,alpha=0,mu0,beta,N0,pos=pos)$res # troubleshoot#
        return(-LH)}#
        } else if (fix.eps==TRUE)#
     {optimLH.coalBD <- function(init) {#
        lamb0 <- init[1]#
        alpha <- init[2]#
        eps <- init[3]#
        LH <- getLikelihood.coalBD(Vtimes,Ntips,lamb0,alpha,d=lamb0*eps,beta=alpha,N0,pos=pos)$res#
        return(-LH)}#
        } else#
     {optimLH.coalBD <- function(init) {#
        lamb0 <- init[1]#
        alpha <- init[2]#
        mu0 <- init[3]#
        beta <- init[4]#
        LH <- getLikelihood.coalBD(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=pos)$res#
        return(-LH)}#
        }#
  #
  #######################################################################################    #
   	#
   	temp <- optim(init, optimLH.coalBD, method = meth,control=list(ndeps=10^(-4)))#
#
		if (mu.0==TRUE & cst.lamb==TRUE)#
      {#
        if (pos==FALSE)#
    	{res <- list(model = "Pure birth constant speciation", LH = -temp$value, aicc = 2 * #
    	temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = temp$par[1])}#
    	else {#
    		res <- list(model = "Pure birth constant speciation", LH = -temp$value, aicc = 2 * #
        temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = abs(temp$par[1]))}#
      } else if (cst.mu==TRUE & cst.lamb==TRUE) { #
        if (pos==FALSE)#
    	{res <- list(model = "Birth-death constant rates", LH = -temp$value, aicc = 2 * #
    	temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = temp$par[1],mu0 = temp$par[2])}#
    	else#
    	{res <- list(model = "Birth-death constant rates", LH = -temp$value, aicc = 2 * #
        temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = abs(temp$par[1]),mu0 = abs(temp$par[2]))}#
        } else if (mu.0==TRUE & cst.lamb==FALSE)#
        { #
        if (pos==FALSE)#
    	{res <- list(model = "Pure birth varying speciation", LH = -temp$value, aicc = 2 * #
    	temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = temp$par[1], alpha = temp$par[2])}#
    	else#
    	{res <- list(model = "Pure birth varying speciation", LH = -temp$value, aicc = 2 * #
        temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = abs(temp$par[1]), alpha = temp$par[2])}#
        } else if (cst.mu==TRUE & cst.lamb==FALSE) #
        { #
        if (pos==FALSE)#
    	{res <- list(model = "Birth-death varying speciation constant extinction", LH = -temp$value, aicc = 2 * #
    	temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = temp$par[1], alpha = temp$par[2], mu0 = temp$par[3])}#
    	else#
    	{res <- list(model = "Birth-death varying speciation constant extinction", LH = -temp$value, aicc = 2 * #
        temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = abs(temp$par[1]), alpha = temp$par[2], mu0 = abs(temp$par[3]))}#
        } else if (cst.mu==FALSE & cst.lamb==TRUE)#
        {#
        if (pos==FALSE)#
    	{res <- list(model = "Birth-death constant speciation varying extinction", LH = -temp$value, aicc = 2 * #
    	temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = temp$par[1], mu0 = temp$par[2], beta = temp$par[3])}#
    	else#
    	{res <- list(model = "Birth-death constant speciation varying extinction", LH = -temp$value, aicc = 2 * #
        temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = abs(temp$par[1]), mu0 = abs(temp$par[2]), beta = temp$par[3])}#
        } else if (fix.eps==TRUE)#
        { #
        if (pos==FALSE)#
    	{res <- list(model = "Birth-death constant extinction fraction", LH = -temp$value, aicc = 2 * #
    	temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = temp$par[1], alpha = temp$par[2], eps = temp$par[3])}#
    	else#
    	{res <- list(model = "Birth-death constant extinction fraction", LH = -temp$value, aicc = 2 * #
        temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = abs(temp$par[1]), alpha = temp$par[2], eps = abs(temp$par[3]))}#
        } else {#
        if (pos==FALSE)#
    	{res <- list(model = "Birth-death varying speciation and extinction", LH = -temp$value, aicc = 2 * #
    	temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = temp$par[1], alpha = temp$par[2], mu0 = temp$par[3],beta = temp$par[4])}#
    	else#
    	{res <- list(model = "Birth-death varying speciation and extinction", LH = -temp$value, aicc = 2 * #
        temp$value + 2*nbpar + 2*nbpar*(nbpar+1)/(nbobs-nbpar-1), lamb0 = abs(temp$par[1]), alpha = temp$par[2], mu0 = abs(temp$par[3]),beta = temp$par[4])}}#
#
        #
        return(res)#
}
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized!#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value#
			#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
	#		vf <- Vectorize(f, c("timeDiff", "Vtimes"), SIMPLIFY = FALSE, USE.NAMES = FALSE)#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
			#
			vfcmp <- cmpfun(vf)#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
			#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun))#
			#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work	#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
	}
require(TreeSim)#
library(foreach)#
#library(multicore)#
#library(doMC)#
#
phylo=sim.bd.taxa.age(1000, 1, lambda=0.1, mu=0.01, age=65, mrca=FALSE)[[1]]#
#
foo <- fitcoalBD(phylo, cst.lamb=TRUE)#
#
system.time(foo <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compile)
library(compiler)
require(TreeSim)#
library(foreach)#
#library(multicore)#
#library(doMC)#
#
phylo=sim.bd.taxa.age(1000, 1, lambda=0.1, mu=0.01, age=65, mrca=FALSE)[[1]]#
#
foo <- fitcoalBD(phylo, cst.lamb=TRUE)#
#
system.time(foo <- fitcoalBD(phylo, cst.lamb=TRUE))
gc()
require(TreeSim)#
library(foreach)#
#library(multicore)#
#library(doMC)#
#
phylo=sim.bd.taxa.age(1000, 1, lambda=0.1, mu=0.01, age=65, mrca=FALSE)[[1]]#
#
foo <- fitcoalBD(phylo, cst.lamb=TRUE)#
#
system.time(foo <- fitcoalBD(phylo, cst.lamb=TRUE))
system.time(foo <- fitcoalBD(phylo, cst.lamb=TRUE))
gc()
system.time(foo <- fitcoalBD(phylo, cst.lamb=TRUE))
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	#
	times<-c(0,sort(Vtimes))#
	#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
		{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
		}#
	#
	else if ((alpha==0) & (beta==0)) #
		{	if (pos==FALSE)#
			{r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))}#
			else #
			{r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))}#
			res<-sum(log(indLikelihood))#
			}#
				#
	else#
	#
	{		#
	if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
			}#
			#
	else if ((alpha==0) & !(beta==0))#
		{	if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
			}#
			#
	else {	if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
			}#
	#
		#
	if (FALSE %in% is.finite(demfun(Vtimes)))#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))}#
		#
	else#
	{	#
	integrals<-c()#
	demfunval<-c()#
	#
	for (i in 1:length(Vtimes))#
	{	#
		demfunvali<-demfun(Vtimes[i])#
		integrali<-integrate(demfun,(Vtimes[i]-Ttimes[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#
		demfunval<-c(demfunval,demfunvali)#
		integrals<-c(integrals,integrali)}#
				#
		indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		res<-sum(log(indLikelihood))#
		}		#
		}	#
		#
		return(list("res"=res,"all"=indLikelihood))}
system.time(foo <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler)#
#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize:#
		#	f <- function (timeDiff, Vtimes, demfun) {#
		#		temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
		#		return(temp)#
		#	}#
#
		#	vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
			for (i in 1:length(Vtimes))#
			{#
				integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
				integrals <- c(integrals,integrali)#
			}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. #
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
	}
gc()
system.time(foo <- fitcoalBD(phylo, cst.lamb=TRUE))
phylo=sim.bd.taxa.age(5000, 1, lambda=0.1, mu=0.01, age=65, mrca=FALSE)[[1]]
gc()
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	#
	times<-c(0,sort(Vtimes))#
	#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
		{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
		}#
	#
	else if ((alpha==0) & (beta==0)) #
		{	if (pos==FALSE)#
			{r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))}#
			else #
			{r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))}#
			res<-sum(log(indLikelihood))#
			}#
				#
	else#
	#
	{		#
	if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
			}#
			#
	else if ((alpha==0) & !(beta==0))#
		{	if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
			}#
			#
	else {	if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
			}#
	#
		#
	if (FALSE %in% is.finite(demfun(Vtimes)))#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))}#
		#
	else#
	{	#
	integrals<-c()#
	demfunval<-c()#
	#
	for (i in 1:length(Vtimes))#
	{	#
		demfunvali<-demfun(Vtimes[i])#
		integrali<-integrate(demfun,(Vtimes[i]-Ttimes[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#
		demfunval<-c(demfunval,demfunvali)#
		integrals<-c(integrals,integrali)}#
				#
		indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		res<-sum(log(indLikelihood))#
		}		#
		}	#
		#
		return(list("res"=res,"all"=indLikelihood))}
system.time(foo.original <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler)#
#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize:#
		#	f <- function (timeDiff, Vtimes, demfun) {#
		#		temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
		#		return(temp)#
		#	}#
#
		#	vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
			for (i in 1:length(Vtimes))#
			{#
				integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
				integrals <- c(integrals,integrali)#
			}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
	}
library(compiler)#
#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize:#
		#	f <- function (timeDiff, Vtimes, demfun) {#
		#		temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
		#		return(temp)#
		#	}#
#
		#	vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
			for (i in 1:length(Vtimes))#
			{#
				integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
				integrals <- c(integrals,integrali)#
			}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize. no speed increase.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
			vfcmp <- cmpfun(vf)#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
			for (i in 1:length(Vtimes))#
			{#
				integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
				integrals <- c(integrals,integrali)#
			}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb.cmp <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize. no speed increase.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
			vfcmp <- cmpfun(vf)#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb.cmp <- fitcoalBD(phylo, cst.lamb=TRUE))
gc()
system.time(foo.jwb.cmp <- fitcoalBD(phylo, cst.lamb=TRUE))
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	#
	times<-c(0,sort(Vtimes))#
	#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
		{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
		}#
	#
	else if ((alpha==0) & (beta==0)) #
		{	if (pos==FALSE)#
			{r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))}#
			else #
			{r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))}#
			res<-sum(log(indLikelihood))#
			}#
				#
	else#
	#
	{		#
	if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
			}#
			#
	else if ((alpha==0) & !(beta==0))#
		{	if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
			}#
			#
	else {	if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
			}#
	#
		#
	if (FALSE %in% is.finite(demfun(Vtimes)))#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))}#
		#
	else#
	{	#
	integrals<-c()#
	demfunval<-c()#
	#
	for (i in 1:length(Vtimes))#
	{	#
		demfunvali<-demfun(Vtimes[i])#
		integrali<-integrate(demfun,(Vtimes[i]-Ttimes[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#
		demfunval<-c(demfunval,demfunvali)#
		integrals<-c(integrals,integrali)}#
				#
		indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		res<-sum(log(indLikelihood))#
		}		#
		}	#
		#
		return(list("res"=res,"all"=indLikelihood))}
gc()
system.time(foo.original <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize. no speed increase.#
		#	f <- function (timeDiff, Vtimes, demfun) {#
		#		temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
		#		return(temp)#
		#	}#
#
		#	vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
			for (i in 1:length(Vtimes))#
			{#
				integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
				integrals <- c(integrals,integrali)#
			}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize. no speed increase.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb.vector <- fitcoalBD(phylo, cst.lamb=TRUE))
gc()
system.time(foo.jwb.vector <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize. no speed increase.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
			vfcmp <- cmpfun(vf)#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb.vector.cmp <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize. no speed increase.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
			vfcmp <- cmpfun(vf)#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb.vector.cmp <- fitcoalBD(phylo, cst.lamb=TRUE))
gc()
system.time(foo.jwb.vector.cmp <- fitcoalBD(phylo, cst.lamb=TRUE))
phylo=sim.bd.taxa.age(10000, 1, lambda=0.1, mu=0.01, age=65, mrca=FALSE)[[1]]
gc()
system.time(foo.jwb.vector.cmp <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# try to vectorize. no speed increase.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation	#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop with looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb.vector <- fitcoalBD(phylo, cst.lamb=TRUE))
ls()
foo.original
foo.jwb
foo.jwb.cmp
ls()
foo.jwb.vector
foo.jwb.vector.cmp
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	#
	times<-c(0,sort(Vtimes))#
	#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
		{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
		}#
	#
	else if ((alpha==0) & (beta==0)) #
		{	if (pos==FALSE)#
			{r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))}#
			else #
			{r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))}#
			res<-sum(log(indLikelihood))#
			}#
				#
	else#
	#
	{		#
	if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
			}#
			#
	else if ((alpha==0) & !(beta==0))#
		{	if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
			}#
			#
	else {	if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
			}#
	#
		#
	if (FALSE %in% is.finite(demfun(Vtimes)))#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))}#
		#
	else#
	{	#
	integrals<-c()#
	demfunval<-c()#
	#
	for (i in 1:length(Vtimes))#
	{	#
		demfunvali<-demfun(Vtimes[i])#
		integrali<-integrate(demfun,(Vtimes[i]-Ttimes[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#
		demfunval<-c(demfunval,demfunvali)#
		integrals<-c(integrals,integrali)}#
				#
		indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		res<-sum(log(indLikelihood))#
		}		#
		}	#
		#
		return(list("res"=res,"all"=indLikelihood))}
gc()
system.time(foo.original <- fitcoalBD(phylo, cst.lamb=TRUE))
ls()
foo.original
foo.jwb.vector
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# vectorize function. best option in terms of speed.#
		#	f <- function (timeDiff, Vtimes, demfun) {#
		#		temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
		#		return(temp)#
		#	}#
#
		#	vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation. actually slows things down a bit.#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
			integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop without looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood))#
	return(list("res"=res))#
}
gc()
system.time(foo.vect.integ <- fitcoalBD(phylo, cst.lamb=TRUE))
foo.vect.integ
foo.jwb.vector
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# vectorize function. best option in terms of speed.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation. actually slows things down a bit.#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop without looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood)) # indLikelihood doesn't seem to be used, so forget it#
	return(list("res"=res))#
}
gc()
system.time(foo.jwb.vector <- fitcoalBD(phylo, cst.lamb=TRUE))
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# vectorize function. best option in terms of speed.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation. actually slows things down a bit.#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop without looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood)) # indLikelihood doesn't seem to be used, so forget it#
	return(list("res"=res))#
}

system("ls -l")
ls()
rm(getLikelihood.coalBD)
system.time(foo.jwb.vector <- fitcoalBD(phylo, cst.lamb=TRUE))
library(compiler) # used for bit-compilation#
#
#This code computes the likelihood of a given phylogeny under various flavors of the birth-death model (Models 2 to 6 from the PloSB 2010 paper), with parameters lamb0,alpha,mu0 and beta, and diversity N0#
getLikelihood.coalBD <- function(Vtimes,Ntips,lamb0,alpha,mu0,beta,N0,pos=TRUE)#
# The extinction rate is forced to be less than the speciation rate over the history of the clade#
#
{#
	Ttimes <- diff(Vtimes)#
	Vtimes <- Vtimes[2:length(Vtimes)]#
	nbint<-length(Ttimes)#
	samp<-seq((Ntips-2),(Ntips-nbint-1),by=-1)#
	times<-c(0,sort(Vtimes))#
#
	if (min(abs(lamb0)*exp(alpha*times)-abs(mu0)*exp(beta*times))<=0)#
	{#
		indLikelihood<-0*vector(length=length(samp))#
		res<-sum(log(indLikelihood))#
	} else if ((alpha==0) & (beta==0)) {#
		if (pos==FALSE)#
		{#
			r<-lamb0-mu0#
			indLikelihood<-samp*(samp+1)/2*2*lamb0/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*lamb0/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		} else {#
			r<-abs(abs(lamb0)-abs(mu0))#
			indLikelihood<-samp*(samp+1)/2*2*abs(lamb0)/N0*1/(exp(-r*Vtimes))*exp(-samp*(samp+1)/2*2*abs(lamb0)/N0/r*exp(r*Vtimes)*(1-exp(-r*Ttimes)))#
		}#
			res<-sum(log(indLikelihood))#
	} else {		#
		if ((beta==0) & !(alpha==0))#
		{	if (pos==FALSE) #
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))+mu0*x))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))+abs(mu0)*x))}}#
		} else if ((alpha==0) & !(beta==0))#
		{#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0/(N0*exp(-lamb0*x-mu0/beta*(1-exp(beta*x))))}}#
			else #
			{demfun<-function(x){2*abs(lamb0)/(N0*exp(-abs(lamb0)*x-abs(mu0)/beta*(1-exp(beta*x))))}}#
		} else {#
			if (pos==FALSE)#
			{demfun<-function(x){2*lamb0*exp(alpha*x)/(N0*exp(lamb0/alpha*(1-exp(alpha*x))-mu0/beta*(1-exp(beta*x))))}}#
			else {demfun<-function(x){2*abs(lamb0)*exp(alpha*x)/(N0*exp(abs(lamb0)/alpha*(1-exp(alpha*x))-abs(mu0)/beta*(1-exp(beta*x))))}}#
		}#
		#
		if (FALSE %in% is.finite(demfun(Vtimes)))#
		{#
			indLikelihood<-0*vector(length=length(samp))#
			res<-sum(log(indLikelihood))#
		} else {#
			integrals <- numeric()#
			demfunval <- numeric()#
			demfunval <- demfun(Vtimes) # no need to loop over this; vectorized! Saves a ton of time.#
			timeDiff <- Vtimes-Ttimes#
			#
		#	integrals <- integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value	# doesn't work; not vectorized. arrggh.#
			#
# vectorize function. best option in terms of speed.#
			f <- function (timeDiff, Vtimes, demfun) {#
				temp <- integrate(f=demfun, timeDiff, Vtimes, stop.on.error=FALSE)$value#
				return(temp)#
			}#
#
			vf <- Vectorize(f, c("timeDiff", "Vtimes"))#
			integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# try bit-compilation. actually slows things down a bit.#
		#	vfcmp <- cmpfun(vf)#
		#	integrals <- as.numeric(vf(timeDiff, Vtimes, demfun))#
		#
# vectorize bit-compiled function	#
		#	gah <- Vectorize(integrate, c("lower", "upper"))#
		#	integrals <- gah(f=demfun, lower=timeDiff, upper=Vtimes, stop.on.error=FALSE)$value#
			#
			#
		#	integrals <- integrate(f=Vectorize(demfun), timeDiff, Vtimes, stop.on.error=FALSE)$value#
			#
# foreach works, but 8X slower#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %do% (f(a, b, demfun))#
		#	integrals <- foreach(a=timeDiff, b=Vtimes, .combine = "c") %dopar% (f(a, b, demfun)) # paralell version. requires (multicore) and (DoMC)#
			#
# slower than for loop, and gives slightly different answer#
		#	integrals <- mapply(FUN=integrate, lower=timeDiff, upper=Vtimes, MoreArgs=list(f=demfun, stop.on.error=FALSE), SIMPLIFY=FALSE, USE.NAMES=FALSE)$value#
			#
#
# do for loop without looping over demfun#
		#	for (i in 1:length(Vtimes))#
		#	{#
		#		integrali <- integrate(demfun,(timeDiff[i]),Vtimes[i],stop.on.error=FALSE)$value#
		#		integrals <- c(integrals,integrali)#
		#	}#
	#		cat("\nLength of integrals is:", length(integrals), "\n", integrals, "\n", sep="")		#
			#
		#	indLikelihood<-samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)#
		#	res<-sum(log(indLikelihood))#
		#
# doesn't work. erg. should work. somehow...#
		#	res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*(integrate(demfun,timeDiff,Vtimes,stop.on.error=FALSE)$value))))#
			#
			res <- sum(log(samp*(samp+1)/2*demfunval*exp(-samp*(samp+1)/2*integrals)))#
		}#
	}#
	#
#	return(list("res"=res,"all"=indLikelihood)) # indLikelihood doesn't seem to be used, so forget it#
	return(list("res"=res))#
}

ls()
rm(getLikelihood.coalBD)
source("/Users/josephwb/Projects/R_working/Matt/getLikelihood.coalBD.JWB.R")
ls()
system.time(foo.jwb.vector <- fitcoalBD(phylo, cst.lamb=TRUE))
require(turboMEDUSA)
############################################################################
#
###required libraries#
##if you do not have the "fields" and "MBA" libraries, you need this step to install them#
install.packages("fields")#
install.packages("MBA")#
## load libraries#
library(fields)#
library(MBA)#
#
###data#
data<-matrix(c(44.9186,81.0824,46.9512,80.1061,49.187,80.7055,57.9268,80.1493,60.3659,81.34,69.3089,80.1941,78.4553,79.2459,91.8699,70.834,99.7967,55.9047,101.2195,30.9102,96.1381,17.3075,85.5691,7.4235,74.3902,4.2299,61.7886,1.8181,55.4878,1.0059,49.187,0.9811,45.3252,1.7532,37.1951,1.9181,20.3252,7.1666,8.9431,17.1612,4.2683,29.1507,4.2683,50.8042,9.5528,66.3761,18.4959,76.2539,29.065,80.6261,38.6179,80.8607,44.9186,81.0824),ncol=2,byrow=TRUE)#
stem<-matrix(c(60.3659,81.34,57.9268,80.1493,49.187,80.7055,46.9512,80.1061,44.9186,81.0824,45.5285,83.6438,47.561,88.1794,44.1057,97.2209,48.7805,99.9952,54.878,87.6176,60.3659,81.34),ncol=2,byrow=TRUE)#
eye<-matrix(c(45.935,46.4407,34.1463,44.8195,36.7886,46.9952,36.382,50.9306,32.3171,53.08,29.065,53.0672,26.0163,49.7086,28.0488,45.1892,20.3252,48.7021,20.1219,55.3942,23.5772,61.1164,30.8942,65.476,32.3171,59.7729,45.935,46.4407),ncol=2,byrow=TRUE)#
eye2<-matrix(c(58.9431,46.6888,65.4472,51.2419,71.748,56.9754,74.3902,65.4504,82.7236,59.7745,84.9593,56.4368,84.7561,48.562,77.439,45.7772,78.8618,50.5072,74.3902,53.6393,69.9186,51.6532,68.6992,47.9083,70.5285,44.9627,58.9431,46.6888),ncol=2,byrow=TRUE)#
mouth<-matrix(c(8.9431,44.7202,23.374,41.2338,30.0813,22.7562,38.2114,38.5363,65.0407,38.445,73.374,22.533,80.2846,40.8673,96.9512,44.673,93.4959,31.8641,84.1463,18.8352,66.2602,9.7097,61.9919,16.1889,59.3496,8.3045,45.5285,8.447,42.8862,16.1137,38.2114,9.4024,22.7642,17.4125,11.9919,31.7401,8.9431,44.7202),ncol=2,byrow=TRUE)#
stars<-matrix(c(sample(seq(0,100),80),sample(seq(20,100),80,replace=TRUE)),ncol=2)#
#
###plot#
par(bg = "black")#
par(mar=c(5,2,4,2))+0.1#
plot(data,type="n",xlim=c(0,100),ylim=c(0,100),xaxt="n",yaxt="n",xlab="",ylab="",axes=FALSE)#
symbols(x=stars[,1],y=stars[,2],circles=rep(0.001,nrow(stars)),inches=0.015,bg="white",xlim=c(0,100),ylim=c(0,100))#
col<-runif(nrow(data),min=4,max=7)#
datmb<-mba.surf(matrix(cbind(data,col),ncol=3),no.X=200,no.Y=200,extend=FALSE)#
image(datmb$xyz,zlim=c(0,10),col=heat.colors(40),add=TRUE)#
polygon(stem,col="darkgreen")#
polygon(eye,col="yellow")#
polygon(eye2,col="yellow")#
polygon(mouth,col="yellow")#
points(data,type="l")#
mtext("Happy Halloween",side=3,col="green3",cex=3.5,font=4)#
mtext("from the EEB and Flow",side=1,col="green3",cex=2.5,font=4)
ls()
load("/Users/josephwb/Projects/R_working/Fossil_MEDUSA/GSA_2011/Code/carnivora.RData")
ls()
carnivora
carnivora$tree
plot(carnivora$tree)
require(ape)
plot(carnivora$tree)
require(turboMEDUSA)
? turboMEDUSA
?getBD
??getBD
?get.b.d
? turboMEDUSA
setwd("/Users/josephwb/Projects/R_working/turboMEDUSA")
source("turboMEDUSA_0.24.R")
load("/Users/josephwb/Projects/R_working/turboMEDUSA/turboMEDUSA/data/carnivora.RData")
ls()
runTurboMEDUSA()
carnivora
carnivora$tree -> phy
carnivora$richness -> richness
runTurboMEDUSA(phy,richness)
source("turboMEDUSA_0.24.R")
runTurboMEDUSA(phy,richness)
